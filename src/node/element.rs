//! Element type for the new PhaseExt-based system.

use smallvec::SmallVec;

use crate::attr::{Attrs, AttrKey, AttrValue, Tag, TextContent};
use crate::core::{PhaseExt, ElementExt, HasStableId};
use crate::id::StableId;

use super::{Node, Text, Children};

/// Element node with tag, attributes, children, and phase extension.
///
/// The extension type `P::Ext` is a single enum containing all family variants,
/// generated by `#[vdom::families]` macro.
#[derive(Debug, Clone)]
pub struct Element<P: PhaseExt> {
    /// Tag name
    pub tag: Tag,
    /// Attributes
    pub attrs: Attrs,
    /// Child nodes
    pub children: Children<P>,
    /// Phase-specific extension (family data)
    pub ext: P::Ext,
}

// =============================================================================
// Constructors
// =============================================================================

impl<P: PhaseExt> Element<P> {
    /// Create element with tag and default extension.
    pub fn new(tag: impl Into<Tag>) -> Self {
        Self {
            tag: tag.into(),
            attrs: Attrs::new(),
            children: SmallVec::new(),
            ext: P::Ext::default(),
        }
    }

    /// Create element with explicit extension.
    pub fn with_ext(tag: impl Into<Tag>, ext: P::Ext) -> Self {
        Self {
            tag: tag.into(),
            attrs: Attrs::new(),
            children: SmallVec::new(),
            ext,
        }
    }

    /// Create element with tag and attributes.
    pub fn with_attrs(tag: impl Into<Tag>, attrs: Attrs) -> Self {
        Self {
            tag: tag.into(),
            attrs,
            children: SmallVec::new(),
            ext: P::Ext::default(),
        }
    }
}

// =============================================================================
// Basic accessors
// =============================================================================

impl<P: PhaseExt> Element<P> {
    /// Get the family name for this element.
    #[inline]
    pub fn family_name(&self) -> &'static str {
        self.ext.family_name()
    }

    /// Check if this is an empty element (no children).
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.children.is_empty()
    }

    /// Get child count.
    #[inline]
    pub fn len(&self) -> usize {
        self.children.len()
    }

    /// Check if tag matches.
    #[inline]
    pub fn is_tag(&self, tag: &str) -> bool {
        self.tag == tag
    }
}

// =============================================================================
// StableId access (for Indexed/Processed phases)
// =============================================================================

impl<P: PhaseExt> Element<P>
where
    P::Ext: HasStableId,
{
    /// Get the stable identifier for this element.
    ///
    /// Available for phases where `Ext` implements `HasStableId`
    /// (typically Indexed and Processed phases).
    #[inline]
    pub fn stable_id(&self) -> StableId {
        self.ext.stable_id()
    }
}

// =============================================================================
// Attribute operations
// =============================================================================

impl<P: PhaseExt> Element<P> {
    /// Get attribute value.
    #[inline]
    pub fn get_attr(&self, name: &str) -> Option<&str> {
        self.attrs.get(name)
    }

    /// Set attribute.
    #[inline]
    pub fn set_attr(&mut self, name: impl Into<AttrKey>, value: impl Into<AttrValue>) {
        self.attrs.set(name.into(), value.into());
    }

    /// Remove attribute.
    #[inline]
    pub fn remove_attr(&mut self, name: &str) -> Option<AttrValue> {
        self.attrs.remove(name)
    }

    /// Check if attribute exists.
    #[inline]
    pub fn has_attr(&self, name: &str) -> bool {
        self.attrs.get(name).is_some()
    }

    /// Get id attribute.
    #[inline]
    pub fn id(&self) -> Option<&str> {
        self.get_attr("id")
    }

    /// Get class attribute.
    #[inline]
    pub fn class(&self) -> Option<&str> {
        self.get_attr("class")
    }

    /// Check if element has a specific class.
    pub fn has_class(&self, class: &str) -> bool {
        self.class()
            .map(|c| c.split_whitespace().any(|c| c == class))
            .unwrap_or(false)
    }

    /// Add a class to the element.
    pub fn add_class(&mut self, class: &str) {
        match self.get_attr("class") {
            Some(existing) => {
                if !existing.split_whitespace().any(|c| c == class) {
                    let new_class = format!("{} {}", existing, class);
                    self.set_attr("class", new_class);
                }
            }
            None => {
                self.set_attr("class", class);
            }
        }
    }
}

// =============================================================================
// Child operations
// =============================================================================

impl<P: PhaseExt> Element<P> {
    /// Push a child element.
    pub fn push_elem(&mut self, elem: Element<P>) {
        self.children.push(Node::Element(Box::new(elem)));
    }

    /// Push a text node.
    pub fn push_text(&mut self, text: impl Into<TextContent>) {
        self.children.push(Node::Text(Text::new(text)));
    }

    /// Push a text node with explicit extension.
    pub fn push_text_with_ext(&mut self, text: impl Into<TextContent>, ext: P::TextExt) {
        self.children.push(Node::Text(Text::with_ext(text, ext)));
    }

    /// Push a child node.
    pub fn push(&mut self, node: Node<P>) {
        self.children.push(node);
    }

    /// Get first child element.
    pub fn first_child(&self) -> Option<&Element<P>> {
        self.children.iter().find_map(|n| n.as_element())
    }

    /// Get first child element mutably.
    pub fn first_child_mut(&mut self) -> Option<&mut Element<P>> {
        self.children.iter_mut().find_map(|n| n.as_element_mut())
    }

    /// Iterate over child elements only.
    pub fn child_elements(&self) -> impl Iterator<Item = &Element<P>> {
        self.children.iter().filter_map(|n| n.as_element())
    }

    /// Iterate over child elements mutably.
    pub fn child_elements_mut(&mut self) -> impl Iterator<Item = &mut Element<P>> {
        self.children.iter_mut().filter_map(|n| n.as_element_mut())
    }

    /// Get text content (concatenated from all text children).
    pub fn text_content(&self) -> String {
        let mut result = String::new();
        Self::collect_text(&self.children, &mut result);
        result
    }

    fn collect_text(children: &[Node<P>], out: &mut String) {
        for child in children {
            match child {
                Node::Text(t) => out.push_str(&t.content),
                Node::Element(e) => Self::collect_text(&e.children, out),
            }
        }
    }

    /// Clear all children.
    pub fn clear(&mut self) {
        self.children.clear();
    }
}

// =============================================================================
// Builder pattern
// =============================================================================

impl<P: PhaseExt> Element<P> {
    /// Builder: set attribute.
    #[must_use]
    pub fn attr(mut self, name: impl Into<AttrKey>, value: impl Into<AttrValue>) -> Self {
        self.set_attr(name, value);
        self
    }

    /// Builder: set id.
    #[must_use]
    pub fn with_id(self, id: impl Into<AttrValue>) -> Self {
        self.attr("id", id)
    }

    /// Builder: set class.
    #[must_use]
    pub fn with_class(self, class: impl Into<AttrValue>) -> Self {
        self.attr("class", class)
    }

    /// Builder: add child element.
    #[must_use]
    pub fn child(mut self, elem: Element<P>) -> Self {
        self.push_elem(elem);
        self
    }

    /// Builder: add text.
    #[must_use]
    pub fn text(mut self, text: impl Into<TextContent>) -> Self {
        self.push_text(text);
        self
    }
}

#[cfg(test)]
mod tests {
    // Tests will use macro-generated phases
}
