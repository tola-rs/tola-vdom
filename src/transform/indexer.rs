//! Generic Indexer for PhaseExt-based phases.
//!
//! Transforms Raw → Indexed using a user-provided indexing function.

use rustc_hash::FxHashMap;

use crate::algo::StableHasher;
use crate::core::{HasStableId, PhaseExt};
use crate::id::{PageSeed, StableId};
use crate::node::{Children, Document, Element, Node, Text};

use super::Transform;

/// Index function type: (RawExt, StableId) -> IndexedExt
pub trait IndexFn<Raw: PhaseExt, Indexed: PhaseExt>: Send + Sync {
    fn index(&self, raw: Raw::Ext, id: StableId) -> Indexed::Ext;
}

/// Blanket implementation for function pointers
impl<Raw, Indexed, F> IndexFn<Raw, Indexed> for F
where
    Raw: PhaseExt,
    Indexed: PhaseExt,
    F: Fn(Raw::Ext, StableId) -> Indexed::Ext + Send + Sync,
{
    fn index(&self, raw: Raw::Ext, id: StableId) -> Indexed::Ext {
        self(raw, id)
    }
}

/// Text index function type: (RawTextExt, StableId) -> IndexedTextExt
pub trait TextIndexFn<Raw: PhaseExt, Indexed: PhaseExt>: Send + Sync {
    fn index(&self, raw: Raw::TextExt, id: StableId) -> Indexed::TextExt;
}

impl<Raw, Indexed, F> TextIndexFn<Raw, Indexed> for F
where
    Raw: PhaseExt,
    Indexed: PhaseExt,
    F: Fn(Raw::TextExt, StableId) -> Indexed::TextExt + Send + Sync,
{
    fn index(&self, raw: Raw::TextExt, id: StableId) -> Indexed::TextExt {
        self(raw, id)
    }
}

/// Doc index function type: (RawDocExt, stats) -> IndexedDocExt
pub trait DocIndexFn<Raw: PhaseExt, Indexed: PhaseExt>: Send + Sync {
    fn index(&self, raw: Raw::DocExt, stats: IndexStats) -> Indexed::DocExt;
}

impl<Raw, Indexed, F> DocIndexFn<Raw, Indexed> for F
where
    Raw: PhaseExt,
    Indexed: PhaseExt,
    F: Fn(Raw::DocExt, IndexStats) -> Indexed::DocExt + Send + Sync,
{
    fn index(&self, raw: Raw::DocExt, stats: IndexStats) -> Indexed::DocExt {
        self(raw, stats)
    }
}

/// Statistics collected during indexing
#[derive(Debug, Clone, Default)]
pub struct IndexStats {
    pub element_count: usize,
    pub text_count: usize,
}

/// Generic Indexer: Raw → Indexed
///
/// Works with any phase system generated by `#[vdom::families]`.
pub struct Indexer<Raw, Indexed, F, TF, DF>
where
    Raw: PhaseExt,
    Indexed: PhaseExt,
    Indexed::Ext: HasStableId,
    F: IndexFn<Raw, Indexed>,
    TF: TextIndexFn<Raw, Indexed>,
    DF: DocIndexFn<Raw, Indexed>,
{
    index_fn: F,
    text_index_fn: TF,
    doc_index_fn: DF,
    page_seed: u64,
    stats: IndexStats,
    _marker: std::marker::PhantomData<(Raw, Indexed)>,
}

impl<Raw, Indexed, F, TF, DF> Indexer<Raw, Indexed, F, TF, DF>
where
    Raw: PhaseExt,
    Indexed: PhaseExt,
    Indexed::Ext: HasStableId,
    F: IndexFn<Raw, Indexed>,
    TF: TextIndexFn<Raw, Indexed>,
    DF: DocIndexFn<Raw, Indexed>,
{
    /// Create a new indexer with the provided functions.
    pub fn new(index_fn: F, text_index_fn: TF, doc_index_fn: DF) -> Self {
        Self {
            index_fn,
            text_index_fn,
            doc_index_fn,
            page_seed: 0,
            stats: IndexStats::default(),
            _marker: std::marker::PhantomData,
        }
    }

    /// Set page seed for globally unique IDs.
    pub fn with_page_seed(mut self, seed: PageSeed) -> Self {
        self.page_seed = seed.as_u64();
        self
    }

    fn index_document(&mut self, doc: Document<Raw>) -> Document<Indexed> {
        let root = self.index_element(doc.root, 0, self.page_seed);
        let meta = self.doc_index_fn.index(doc.meta, self.stats.clone());

        Document::with_meta(root, meta)
    }

    fn index_element(
        &mut self,
        elem: Element<Raw>,
        occurrence: usize,
        parent_seed: u64,
    ) -> Element<Indexed> {
        self.stats.element_count += 1;

        let id = StableId::for_element(&elem.tag, &elem.attrs, &[], occurrence, parent_seed);
        let my_seed = id.0;

        let indexed_ext = self.index_fn.index(elem.ext, id);
        let children = self.index_children(elem.children, my_seed);

        let mut indexed = Element::with_ext(elem.tag, indexed_ext);
        indexed.attrs = elem.attrs;
        indexed.children = children;
        indexed
    }

    fn index_children(
        &mut self,
        children: Children<Raw>,
        parent_seed: u64,
    ) -> Children<Indexed> {
        let mut occurrence_counts: FxHashMap<ContentKey, usize> = FxHashMap::default();

        children
            .into_iter()
            .map(|child| {
                let key = ContentKey::from_node(&child);
                let occurrence = occurrence_counts.entry(key).or_insert(0);
                let current = *occurrence;
                *occurrence += 1;

                self.index_node(child, current, parent_seed)
            })
            .collect()
    }

    fn index_node(&mut self, node: Node<Raw>, occurrence: usize, parent_seed: u64) -> Node<Indexed> {
        match node {
            Node::Element(elem) => {
                Node::Element(Box::new(self.index_element(*elem, occurrence, parent_seed)))
            }
            Node::Text(text) => {
                self.stats.text_count += 1;
                let id = StableId::for_text(occurrence, parent_seed);
                let indexed_ext = self.text_index_fn.index(text.ext, id);
                // Preserve TextKind (Raw/Escaped) when transforming
                let mut indexed_text = Text::with_ext(text.content, indexed_ext);
                indexed_text.kind = text.kind;
                Node::Text(indexed_text)
            }
        }
    }
}

impl<Raw, Indexed, F, TF, DF> Transform<Raw> for Indexer<Raw, Indexed, F, TF, DF>
where
    Raw: PhaseExt,
    Indexed: PhaseExt,
    Indexed::Ext: HasStableId,
    F: IndexFn<Raw, Indexed>,
    TF: TextIndexFn<Raw, Indexed>,
    DF: DocIndexFn<Raw, Indexed>,
{
    type To = Indexed;

    fn transform(mut self, doc: Document<Raw>) -> Document<Indexed> {
        self.index_document(doc)
    }
}

// =============================================================================
// ContentKey (from original indexer)
// =============================================================================

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum ContentKey {
    Element { tag_hash: u64, key_hash: u64 },
    Text { content_hash: u64 },
}

impl ContentKey {
    fn from_node<P: PhaseExt>(node: &Node<P>) -> Self {
        match node {
            Node::Element(elem) => {
                let tag_hash = StableHasher::new().update_str(&elem.tag).finish();
                let mut attr_hasher = StableHasher::new();
                for (k, v) in &elem.attrs {
                    if k == "id" || k == "key" || k.starts_with("data-key") {
                        attr_hasher = attr_hasher.update_str(k).update_str(v);
                    }
                }
                ContentKey::Element {
                    tag_hash,
                    key_hash: attr_hasher.finish(),
                }
            }
            Node::Text(text) => {
                let content_hash = StableHasher::new().update_str(&text.content).finish();
                ContentKey::Text { content_hash }
            }
        }
    }
}

// =============================================================================
// Simplified Indexer (macro-friendly)
// =============================================================================

/// Simplified indexer creation macro.
///
/// Usage:
/// ```ignore
/// let indexer = Indexer::simple(
///     MySite::index_ext,
///     |_, id| IndexedTextExt { stable_id: id },
///     |raw, stats| IndexedDocExt { source_path: raw.source_path, node_count: stats.element_count + stats.text_count },
/// );
/// ```
impl<Raw, Indexed> Indexer<Raw, Indexed, fn(Raw::Ext, StableId) -> Indexed::Ext, fn(Raw::TextExt, StableId) -> Indexed::TextExt, fn(Raw::DocExt, IndexStats) -> Indexed::DocExt>
where
    Raw: PhaseExt,
    Indexed: PhaseExt,
    Indexed::Ext: HasStableId,
{
    // Note: This impl is just for showing the type signature.
    // Actual usage requires providing the closures.
}
