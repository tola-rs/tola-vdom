//! Generic Processor for PhaseExt-based phases.
//!
//! Transforms Indexed → Processed using a user-provided processing function.

use crate::core::{HasStableId, PhaseExt};
use crate::node::{Children, Document, Element, Node, Text};

use super::Transform;

/// Process function type: (&IndexedExt) -> ProcessedExt
pub trait ProcessFn<Indexed: PhaseExt, Processed: PhaseExt>: Send + Sync {
    fn process(&self, indexed: &Indexed::Ext) -> Processed::Ext;
}

impl<Indexed, Processed, F> ProcessFn<Indexed, Processed> for F
where
    Indexed: PhaseExt,
    Processed: PhaseExt,
    F: Fn(&Indexed::Ext) -> Processed::Ext + Send + Sync,
{
    fn process(&self, indexed: &Indexed::Ext) -> Processed::Ext {
        self(indexed)
    }
}

/// Doc process function type: (&IndexedDocExt) -> ProcessedDocExt
pub trait DocProcessFn<Indexed: PhaseExt, Processed: PhaseExt>: Send + Sync {
    fn process(&self, indexed: &Indexed::DocExt) -> Processed::DocExt;
}

impl<Indexed, Processed, F> DocProcessFn<Indexed, Processed> for F
where
    Indexed: PhaseExt,
    Processed: PhaseExt,
    F: Fn(&Indexed::DocExt) -> Processed::DocExt + Send + Sync,
{
    fn process(&self, indexed: &Indexed::DocExt) -> Processed::DocExt {
        self(indexed)
    }
}

/// Generic Processor: Indexed → Processed
///
/// Works with any phase system generated by `#[vdom::families]`.
pub struct Processor<Indexed, Processed, F, DF>
where
    Indexed: PhaseExt,
    Indexed::Ext: HasStableId,
    Processed: PhaseExt,
    F: ProcessFn<Indexed, Processed>,
    DF: DocProcessFn<Indexed, Processed>,
{
    process_fn: F,
    doc_process_fn: DF,
    _marker: std::marker::PhantomData<(Indexed, Processed)>,
}

impl<Indexed, Processed, F, DF> Processor<Indexed, Processed, F, DF>
where
    Indexed: PhaseExt,
    Indexed::Ext: HasStableId,
    Processed: PhaseExt,
    F: ProcessFn<Indexed, Processed>,
    DF: DocProcessFn<Indexed, Processed>,
{
    /// Create a new processor with the provided functions.
    pub fn new(process_fn: F, doc_process_fn: DF) -> Self {
        Self {
            process_fn,
            doc_process_fn,
            _marker: std::marker::PhantomData,
        }
    }

    fn process_document(&self, doc: Document<Indexed>) -> Document<Processed> {
        let root = self.process_element(doc.root);
        let meta = self.doc_process_fn.process(&doc.meta);

        Document::with_meta(root, meta)
    }

    fn process_element(&self, elem: Element<Indexed>) -> Element<Processed> {
        let children = self.process_children(elem.children);
        let processed_ext = self.process_fn.process(&elem.ext);

        let mut processed = Element::with_ext(elem.tag, processed_ext);
        processed.attrs = elem.attrs;
        processed.children = children;
        processed
    }

    fn process_children(&self, children: Children<Indexed>) -> Children<Processed> {
        children
            .into_iter()
            .map(|child| self.process_node(child))
            .collect()
    }

    fn process_node(&self, node: Node<Indexed>) -> Node<Processed> {
        match node {
            Node::Element(elem) => {
                Node::Element(Box::new(self.process_element(*elem)))
            }
            Node::Text(text) => {
                // Preserve TextKind (Raw/Escaped) when transforming
                Node::Text(Text::from_other_default(text))
            }
        }
    }
}

impl<Indexed, Processed, F, DF> Transform<Indexed> for Processor<Indexed, Processed, F, DF>
where
    Indexed: PhaseExt,
    Indexed::Ext: HasStableId,
    Processed: PhaseExt,
    F: ProcessFn<Indexed, Processed>,
    DF: DocProcessFn<Indexed, Processed>,
{
    type To = Processed;

    fn transform(self, doc: Document<Indexed>) -> Document<Processed> {
        self.process_document(doc)
    }
}
