//! Core traits for the VDOM type system.
//!
//! # Architecture
//!
//! ```text
//! Family ──► defines data types for each phase
//!    │
//!    ▼
//! FamilySet ──► combines families into a phase
//!    │
//!    ▼
//! Phase ──► Raw / Indexed / Processed
//!    │
//!    ▼
//! Document<P> / Element<P>
//! ```
//!
//! # Design Principles
//!
//! 1. **Equality**: Built-in and user-defined families use identical mechanisms
//! 2. **Full Lifecycle**: Family data preserved through all phases
//! 3. **Compile-time**: All types determined at compile time, zero runtime overhead
//! 4. **Extensible**: Users define families with same power as built-ins

use std::fmt::Debug;

use crate::id::StableId;

// =============================================================================
// Family Trait
// =============================================================================

/// A family defines element extension data for each compilation phase.
///
/// Built-in families (Link, Heading, Svg, Media) and user-defined families
/// use this same trait - there's no special treatment for built-ins.
///
/// # Example
///
/// ```ignore
/// pub struct LinkFamily;
///
/// impl Family for LinkFamily {
///     const NAME: &'static str = "link";
///
///     type Raw = LinkRaw;
///     type Indexed = LinkIndexed;
///     type Processed = LinkProcessed;
///
///     fn identify(tag: &str, attrs: &Attrs) -> bool {
///         tag == "a" || attrs.contains_key("href")
///     }
///
///     fn index(raw: Self::Raw, id: StableId) -> Self::Indexed { ... }
///     fn process(indexed: &Self::Indexed) -> Self::Processed { ... }
/// }
/// ```
pub trait Family: 'static + Send + Sync {
    /// Family name for debugging and serialization
    const NAME: &'static str;

    /// Data at Raw phase (from parser/generator)
    type Raw: FamilyData;

    /// Data at Indexed phase (with StableId)
    type Indexed: FamilyData + HasStableId;

    /// Data at Processed phase (after transformations)
    type Processed: FamilyData + HasStableId;

    /// Identify if an element belongs to this family
    fn identify(tag: &str, attrs: &crate::attr::Attrs) -> bool;

    /// Transform Raw → Indexed
    fn index(raw: Self::Raw, id: StableId) -> Self::Indexed;

    /// Transform Indexed → Processed
    fn process(indexed: &Self::Indexed) -> Self::Processed;
}

/// Bounds for family data types
pub trait FamilyData: Debug + Clone + Default + Send + Sync + 'static {}

impl<T> FamilyData for T where T: Debug + Clone + Default + Send + Sync + 'static {}

/// Access to StableId for indexed/processed phases
pub trait HasStableId {
    fn stable_id(&self) -> StableId;
}

// =============================================================================
// Phase Trait
// =============================================================================

/// Marker trait for VDOM phases.
pub trait Phase: 'static + Send + Sync + Debug + Clone + Copy {
    const NAME: &'static str;
}

/// Phase with associated extension types.
///
/// The `Ext` type is typically an enum generated by `#[vdom::phase]` macro,
/// containing variants for each family in the phase.
pub trait PhaseExt: Phase {
    /// Element extension type (enum of all families)
    type Ext: ElementExt;

    /// Document metadata
    type DocExt: Debug + Clone + Default + Send + Sync;

    /// Text node extension
    type TextExt: Debug + Clone + Default + Send + Sync;
}

/// Element extension trait - unified interface for family enum
pub trait ElementExt: Debug + Clone + Default + Send + Sync {
    /// Get family name
    fn family_name(&self) -> &'static str;
}

/// Element extension with StableId (for Indexed/Processed phases)
pub trait IndexedExt: ElementExt + HasStableId {}

impl<T: ElementExt + HasStableId> IndexedExt for T {}

// =============================================================================
// Phase Markers
// =============================================================================

/// Marker for Raw-like phases
pub trait RawPhaseMarker: PhaseExt {}

/// Marker for Indexed-like phases
pub trait IndexedPhaseMarker: PhaseExt
where
    Self::Ext: HasStableId,
    Self::TextExt: HasStableId,
{
}

/// Marker for Processed-like phases
pub trait ProcessedPhaseMarker: PhaseExt
where
    Self::Ext: HasStableId,
{
}

// =============================================================================
// FamilySet - GAT-based type-safe family access
// =============================================================================

/// A set of families with GAT-based type-safe data access.
///
/// This trait provides compile-time type-safe access to family data
/// via Generic Associated Types (GATs). The macro `#[vdom::families]`
/// generates implementations of this trait.
///
/// # Design
///
/// The key insight is that while we store data in an enum (for runtime
/// flexibility), we can provide type-safe access via GAT:
///
/// ```ignore
/// // Storage: enum (runtime determined)
/// pub enum IndexedExt {
///     Link(LinkIndexed),
///     Heading(HeadingIndexed),
///     // ...
/// }
///
/// // Access: GAT (compile-time type-safe)
/// impl FamilySet for MySite {
///     type Data<F: Family, P: Phase> = /* F::Raw | F::Indexed | F::Processed */;
/// }
/// ```
///
/// # Example
///
/// ```ignore
/// #[vdom::families]
/// pub struct MySite {
///     link: LinkFamily,
///     heading: HeadingFamily,
///     math: MathFamily,  // user-defined
/// }
///
/// // Type-safe access
/// fn process_link<S: FamilySet>(data: &S::Data<LinkFamily, S::Indexed>) {
///     // data is exactly LinkIndexed, not an enum
/// }
/// ```
pub trait FamilySet: 'static + Send + Sync {
    /// GAT: Get the concrete data type for a (Family, Phase) combination.
    ///
    /// For example:
    /// - `Data<LinkFamily, Raw>` = `LinkRaw`
    /// - `Data<LinkFamily, Indexed>` = `LinkIndexed`
    /// - `Data<HeadingFamily, Processed>` = `HeadingProcessed`
    type Data<F: Family, P: Phase>: FamilyData;

    /// The Raw phase type for this family set
    type Raw: PhaseExt;

    /// The Indexed phase type for this family set
    type Indexed: PhaseExt;

    /// The Processed phase type for this family set
    type Processed: PhaseExt;

    /// Check if a family is included in this set
    fn contains<F: Family>() -> bool;
}

// =============================================================================
// ExtractFamily - GAT-based family data extraction
// =============================================================================

/// Extract family-specific data from a phase extension enum.
///
/// This trait bridges the runtime enum storage with compile-time
/// type-safe access. Implemented by macro-generated extension enums.
///
/// # Example
///
/// ```ignore
/// let ext: MySite::IndexedExt = /* ... */;
///
/// // Type-safe extraction
/// if let Some(link_data) = ext.get::<LinkFamily>() {
///     // link_data: &LinkIndexed (exact type, not enum)
///     println!("href: {:?}", link_data.href);
/// }
/// ```
pub trait ExtractFamily<F: Family> {
    /// The concrete data type for this family
    type Output;

    /// Try to extract family data (returns None if wrong family)
    fn get(&self) -> Option<&Self::Output>;

    /// Try to extract family data mutably
    fn get_mut(&mut self) -> Option<&mut Self::Output>;
}

// =============================================================================
// Serialization Support
// =============================================================================

/// Family with serialization support.
///
/// The `Flat` type must derive rkyv's `Archive`, `Serialize`, `Deserialize`:
///
/// ```ignore
/// #[derive(Archive, RkyvSerialize, RkyvDeserialize, Debug, Clone, Default)]
/// #[rkyv(crate = rkyv, derive(Debug))]
/// pub struct FlatMyFamily {
///     // serializable fields...
/// }
/// ```
#[cfg(feature = "cache")]
pub trait SerializableFamily: Family {
    /// Flattened data for rkyv serialization.
    /// Must derive `rkyv::{Archive, Serialize, Deserialize}`.
    type Flat: Debug + Clone + Default + Send + Sync;

    /// Convert Indexed → Flat
    fn to_flat(indexed: &Self::Indexed) -> Self::Flat;

    /// Convert Flat → Indexed
    fn from_flat(flat: &Self::Flat, id: StableId) -> Self::Indexed;
}

// =============================================================================
// None Family (fallback)
// =============================================================================

/// Fallback family for elements that don't match any defined family.
pub struct NoneFamily;

impl Family for NoneFamily {
    const NAME: &'static str = "none";

    type Raw = ();
    type Indexed = NoneIndexed;
    type Processed = NoneProcessed;

    fn identify(_tag: &str, _attrs: &crate::attr::Attrs) -> bool {
        true // Matches everything (used as fallback)
    }

    fn index(_raw: Self::Raw, id: StableId) -> Self::Indexed {
        NoneIndexed { stable_id: id }
    }

    fn process(indexed: &Self::Indexed) -> Self::Processed {
        NoneProcessed {
            stable_id: indexed.stable_id,
        }
    }
}

#[derive(Debug, Clone, Default)]
pub struct NoneIndexed {
    pub stable_id: StableId,
}

impl HasStableId for NoneIndexed {
    fn stable_id(&self) -> StableId {
        self.stable_id
    }
}

#[derive(Debug, Clone, Default)]
pub struct NoneProcessed {
    pub stable_id: StableId,
}

impl HasStableId for NoneProcessed {
    fn stable_id(&self) -> StableId {
        self.stable_id
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_none_family() {
        let indexed = NoneFamily::index((), StableId::from_raw(123));
        assert_eq!(indexed.stable_id().as_raw(), 123);

        let processed = NoneFamily::process(&indexed);
        assert_eq!(processed.stable_id().as_raw(), 123);
    }
}
